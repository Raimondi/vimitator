# vim:set ft=ruby:
class Vimitator::Parser

prechigh
  nonassoc UNOT UMINUS UPLUS
  left STAR SLASH
  left PLUS MINUS
  right ASSIGN
preclow

rule

vimexpr : expr1 { result = ExpressionStatementNode.new(val.first) }

expr1 : expr2
      | expr2 QUESTION expr1 COLON expr1   {
          result = ConditionalNode.new(val[0], val[2], val[4])
        }

expr2 : expr3
      | expr2 OR expr3          {result = val}

expr3 : expr4
      | expr3 AND expr4         {result = val}

expr4 : expr5
      | expr4 CMPOP expr5       {result = val}

expr5 : expr6
      | expr5 CATDOT expr6     { result = CatenateNode.new(val[0],val[2])}
      | expr5 MINUS expr6      { result = SubtractNode.new(val[0],val[2])}
      | expr5 PLUS expr6       { result = AddNode.new(val[0],val[2])}


expr6 : expr7
      | expr6 MODULUS expr7    { result = ModulusNode.new(val[0],val[2])}
      | expr6 SLASH expr7      { result = DivideNode.new(val[0],val[2])}
      | expr6 STAR expr7       { result = MultiplyNode.new(val[0],val[2])}

expr7 : expr8
      | NOT expr7     =UNOT     {result = val}
      | MINUS expr7   =UMINUS   {result = val}
      | PLUS expr7    =UPLUS    {result = val}

expr8 : expr9
      | funcrefcall
      | dictdot
      | idxrange
      | index

index       : expr8 LSQUARE expr1 RSQUARE              {result = val}
idxrange    : expr8 LSQUARE expr1 COLON expr1 RSQUARE  {result = val}
            | expr8 LSQUARE COLON expr1 RSQUARE        {result = val}
            | expr8 LSQUARE expr1 COLON RSQUARE        {result = val}
            | expr8 LSQUARE COLON RSQUARE              {result = val}
dictdot     : expr8 DICDOT word                        {result = val}
funcrefcall : expr8 LPAREN exprlist RPAREN             {result = val}
            | expr8 LPAREN RPAREN                      {result = val}

expr9 :
      | REGISTER {result = [:register, val[0]]}
      | ENVVAR   {result = [:envvar, val[0]]}
      | OPTION   {result = [:option, val[0]]}
      | SQSTRING {result = [:sqstring, val[0]]}
      | DQSTRING {result = [:dqstring, val[0]]}
      | list
      | dictionary
      | nested
      | funccall
      | variable  {result = [:variable, val[0]]}
      | FLOAT     { result = NumberNode.new(val.first) }
      | NUMBER    { result = NumberNode.new(val.first) }

nested     : LPAREN expr1 RPAREN             {result = val}
dictionary : LCURLY dictlist RCURLY          {result = val}
           | LCURLY RCURLY                   {result = val}
dictlist   : dictitem
           | dictlist COMMA dictitem         {result = val}
dictitem   : expr1 COLON expr1               {result = val}
list       : LSQUARE exprlist RSQUARE        {result = val}
           | LSQUARE RSQUARE                 {result = val}
funccall   : variable LPAREN exprlist RPAREN {result = val}
           | variable LPAREN RPAREN          {result = val}
exprlist   : expr1
           | exprlist COMMA expr1            {result = val}
variable   : startofident
           | variable NUMBER                 {result = val[0] + val[1].to_s}
           | variable namespace              {result = val[0] + val[1]}
           | variable startofident           {result = val[0] + val[1]}

namespace : HASH wordchar
          | HASH braceident
          # ^-- that doesn't look right  XXX
word : wordchar                              {result = val}
     | word wordchar                         {result = val}
wordchar : NUMBER
         | HEAD
startofident : braceident
             | HEAD
braceident : LCURLY variable RCURLY             {result = val.join}

end

---- header
  require "vimitator/nodes"

---- inner
  include Vimitator::Nodes

