class Vimitator::Parser

prechigh
  nonassoc UNOT UMINUS UPLUS
  left STAR SLASH
  left PLUS MINUS
  right ASSIGN
preclow

rule

# let : LET variable ASSIGN vimexpr { result = LetNode.new(val[1], val[3]);puts result.inspect }

source_elements:
    /* nothing */         { result = SourceElementsNode.new([]) }
  | source_element_list   { result = SourceElementsNode.new([val].flatten) }

source_element_list :
    source_element
  | source_element_list source_element {result = val.flatten}

source_element :
    statement

statement: variable_statement

variable_statement :
  LET variable_declaration {
    result = VarStatementNode.new(val[1])
    # debug(result)
  }

variable_declaration :
  variable initializer {
    result = VarDeclNode.new(val.first, val[1])
  }

# FIXME: include actual ASSIGN in AssignExprNode()
initializer : ASSIGN vimexpr {
    result = AssignExprNode.new(val[1])
  }

# XXX: Dunno if we should keep ExpressionStatementNode() here or not...?
# rkelly doesn't use ExpressionStatementNode() in a var decl...
# vimexpr : expr1 { result = ExpressionStatementNode.new(val.first) }
vimexpr : expr1 { result = val.first }

expr1 : expr2
      | expr2 QUESTION expr1 COLON expr1   {
          result = ConditionalNode.new(val[0], val[2], val[4])
        }

expr2 : expr3
      | expr2 OR expr3          {result = val}

expr3 : expr4
      | expr3 AND expr4         {result = val}

expr4 : expr5
      | expr4 CMPOP expr5       {result = val}

expr5 : expr6
      | expr5 CATDOT expr6     { result = CatenateNode.new(val[0],val[2])}
      | expr5 MINUS expr6      { result = SubtractNode.new(val[0],val[2])}
      | expr5 PLUS expr6       { result = AddNode.new(val[0],val[2])}


expr6 : expr7
      | expr6 MODULUS expr7    { result = ModulusNode.new(val[0],val[2])}
      | expr6 SLASH expr7      { result = DivideNode.new(val[0],val[2])}
      | expr6 STAR expr7       { result = MultiplyNode.new(val[0],val[2])}

expr7 : expr8
      | NOT expr7     =UNOT     {result = val}
      | MINUS expr7   =UMINUS   {result = val}
      | PLUS expr7    =UPLUS    {result = val}

expr8 : expr9
      | funcrefcall
      | dictdot
      | idxrange
      | index

index       : expr8 LSQUARE expr1 RSQUARE              {result = val}
idxrange    : expr8 LSQUARE expr1 COLON expr1 RSQUARE  {result = val}
            | expr8 LSQUARE COLON expr1 RSQUARE        {result = val}
            | expr8 LSQUARE expr1 COLON RSQUARE        {result = val}
            | expr8 LSQUARE COLON RSQUARE              {result = val}
dictdot     : expr8 DICDOT word                        {result = val}
funcrefcall : expr8 LPAREN exprlist RPAREN             {result = val}
            | expr8 LPAREN RPAREN                      {result = val}

expr9 :
      | REGISTER {result = [:register, val[0]]}
      | ENVVAR   {result = [:envvar, val[0]]}
      | OPTION   {result = [:option, val[0]]}
      | SQSTRING {result = [:sqstring, val[0]]}
      | DQSTRING {result = [:dqstring, val[0]]}
      | list
      | dictionary
      | nested
      | funccall
      | variable
      | FLOAT     { result = NumberNode.new(val.first) }
      | NUMBER    { result = NumberNode.new(val.first) }

nested     : LPAREN expr1 RPAREN             {result = val}
dictionary : LCURLY dictlist RCURLY          {result = val}
           | LCURLY RCURLY                   {result = val}
dictlist   : dictitem
           | dictlist COMMA dictitem         {result = val}
dictitem   : expr1 COLON expr1               {result = val}
list       : LSQUARE exprlist RSQUARE        {result = val}
           | LSQUARE RSQUARE                 {result = val}
funccall   : ident LPAREN exprlist RPAREN {result = val}
           | ident LPAREN RPAREN          {result = val}
exprlist   : expr1
           | exprlist COMMA expr1         {result = val}
variable : ident                          {result = val}
ident   : startofident
           | ident NUMBER                 {result = val[0] + val[1].to_s}
           | ident namespace              {result = val[0] + val[1]}
           | ident startofident           {result = val[0] + val[1]}

namespace : HASH wordchar
          | HASH braceident
          # ^-- that doesn't look right  XXX
word : wordchar                              {result = val}
     | word wordchar                         {result = val}
wordchar : NUMBER
         | HEAD
startofident : braceident
             | HEAD
braceident : LCURLY variable RCURLY             {result = val.join}

end

---- header
  require "vimitator/nodes"

---- inner
  include Vimitator::Nodes

